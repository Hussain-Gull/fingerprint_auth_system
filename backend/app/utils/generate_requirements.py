#!/usr/bin/env python3
"""
Script to generate requirements.txt with exact versions from the current virtual environment.
This script will identify all installed packages and create a requirements.txt file with exact versions.
"""

import subprocess
import sys
import os
from pathlib import Path

def get_installed_packages():
    """Get all installed packages with their exact versions."""
    try:
        # Run pip freeze to get all installed packages with versions
        result = subprocess.run([sys.executable, '-m', 'pip', 'freeze'], 
                              capture_output=True, text=True, check=True)
        
        packages = []
        for line in result.stdout.strip().split('\n'):
            if line and not line.startswith('#'):
                packages.append(line)
        
        return packages
    except subprocess.CalledProcessError as e:
        print(f"Error running pip freeze: {e}")
        return []
    except Exception as e:
        print(f"Unexpected error: {e}")
        return []

def filter_relevant_packages(packages):
    """Filter packages to only include relevant ones (exclude pip, setuptools, etc.)."""
    exclude_packages = {
        'pip', 'setuptools', 'wheel', 'pkg-resources', 'distribute'
    }
    
    relevant_packages = []
    for package in packages:
        package_name = package.split('==')[0].split('>=')[0].split('<=')[0].split('~=')[0]
        if package_name.lower() not in exclude_packages:
            relevant_packages.append(package)
    
    return relevant_packages

def update_requirements_file(packages, requirements_path):
    """Update the requirements.txt file with exact versions."""
    try:
        # Sort packages alphabetically for better organization
        packages.sort()
        
        # Write to requirements.txt
        with open(requirements_path, 'w', encoding='utf-8') as f:
            f.write("# Auto-generated requirements.txt with exact versions\n")
            f.write("# Generated by generate_requirements.py\n")
            f.write("# Run this script whenever you install new packages\n\n")
            
            for package in packages:
                f.write(f"{package}\n")
        
        print(f"Successfully updated {requirements_path}")
        print(f"Found {len(packages)} packages")
        
    except Exception as e:
        print(f"Error writing to requirements.txt: {e}")

def main():
    """Main function to generate requirements.txt."""
    print("Scanning installed packages...")
    
    # Get current directory
    current_dir = Path(__file__).parent
    requirements_path = current_dir / "requirements.txt"
    
    # Get installed packages
    packages = get_installed_packages()
    
    if not packages:
        print("No packages found or error occurred")
        return
    
    print(f"Found {len(packages)} total packages")
    
    # Filter relevant packages
    relevant_packages = filter_relevant_packages(packages)
    
    print(f"Filtered to {len(relevant_packages)} relevant packages")
    
    # Update requirements.txt
    update_requirements_file(relevant_packages, requirements_path)
    
    # Display some of the packages
    print("\nSample packages found:")
    for i, package in enumerate(relevant_packages[:10]):  # Show first 10
        print(f"  {i+1:2d}. {package}")
    
    if len(relevant_packages) > 10:
        print(f"  ... and {len(relevant_packages) - 10} more packages")
    
    print(f"\nRequirements.txt updated successfully!")
    print(f"Location: {requirements_path.absolute()}")

if __name__ == "__main__":
    main()
